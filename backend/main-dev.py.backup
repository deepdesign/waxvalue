"""
WaxValue Backend - Real Discogs Integration Only
No mock data - uses real Discogs API and user sessions
"""

from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
import json
from datetime import datetime, timedelta
import os
import logging
from dotenv import load_dotenv
from discogs_client import DiscogsClient, DiscogsOAuth
import secrets

# Load environment variables
load_dotenv()

# Configure logging
logger = logging.getLogger(__name__)

app = FastAPI(title="WaxValue API", version="1.0.0")

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Import persistent session manager
from session_manager import session_manager

# Pydantic models
class User(BaseModel):
    id: str
    username: str
    discogsUserId: Optional[int] = None
    email: Optional[str] = None
    firstName: Optional[str] = None
    lastName: Optional[str] = None
    accessToken: Optional[str] = None
    accessTokenSecret: Optional[str] = None

class UserSettings(BaseModel):
    currency: str = "USD"
    defaultDryRun: bool = True
    dailySchedule: str = "09:00"
    globalFloor: float = 5.0
    globalCeiling: float = 1000.0
    maxChangePercent: int = 25
    apiRateLimitSeconds: float = 1.2
    logRetentionDays: int = 90
    autoUpdateIncreases: bool = False
    alertThreshold: int = 25

class Strategy(BaseModel):
    id: str
    name: str
    description: str
    anchorMetric: str
    offset: float
    offsetType: str
    isActive: bool = False

class PriceSuggestion(BaseModel):
    listingId: int
    releaseId: int
    currentPrice: float
    suggestedPrice: float
    confidence: str
    basis: str
    condition: str
    sleeveCondition: str
    decision: Optional[str] = None
    reason: Optional[str] = None
    reasoning: Optional[str] = None
    marketData: Optional[Dict[str, Any]] = None
    release: Optional[Dict[str, Any]] = None
    artist: Optional[str] = None

class RunLog(BaseModel):
    id: str
    runDate: str
    isDryRun: bool
    status: str
    itemsScanned: int
    itemsUpdated: int
    itemsSkipped: int
    errors: int
    errorMessage: Optional[str] = None

# Default strategies
DEFAULT_STRATEGIES = [
        Strategy(
        id="conservative",
        name="Conservative",
        description="Median -5% with safety limits",
            anchorMetric="median",
        offset=-5.0,
            offsetType="percentage",
            isActive=True
    ),
    Strategy(
        id="aggressive",
        name="Aggressive",
        description="Median +10% for quick sales",
        anchorMetric="median",
        offset=10.0,
        offsetType="percentage",
        isActive=False
    ),
    Strategy(
        id="competitive",
        name="Competitive",
        description="Median -2% for competitive pricing",
        anchorMetric="median",
        offset=-2.0,
        offsetType="percentage",
        isActive=False
    )
]

def get_current_user(session_id: str) -> Optional[User]:
    """Get current user from session"""
    logger.info(f"Getting user for session: {session_id[:10]}...")
    logger.info(f"Available sessions: {list(session_manager.sessions.keys())}")
    
    if not session_manager.has_session(session_id):
        logger.error(f"Session {session_id[:10]}... not found in sessions")
        return None
    
    session_data = session_manager.get_session(session_id).get("user", {})
    logger.info(f"Session data keys: {list(session_data.keys())}")
    
    # Debug: Check access tokens specifically
    access_token = session_data.get("accessToken")
    access_token_secret = session_data.get("accessTokenSecret")
    logger.info(f"Session {session_id[:10]}... access token: {access_token[:10] if access_token else 'None'}...")
    logger.info(f"Session {session_id[:10]}... access token secret: {access_token_secret[:10] if access_token_secret else 'None'}...")
    
    try:
        user = User(**session_data)
        logger.info(f"Successfully created User object for session {session_id[:10]}...")
        return user
    except Exception as e:
        logger.error(f"Failed to create User object: {e}")
        return None

def require_auth(session_id: str) -> User:
    """Require authenticated user"""
    user = get_current_user(session_id)
    if not user:
        raise HTTPException(status_code=401, detail="Authentication required")
    return user

def require_discogs_auth(user: User) -> None:
    """Require Discogs authentication"""
    if not user.accessToken or not user.accessTokenSecret:
        raise HTTPException(status_code=401, detail="Discogs authentication required")

# Auth endpoints
@app.get("/auth/me")
async def get_current_user_endpoint(session_id: str = None):
    """Get current user info"""
    if not session_id:
        raise HTTPException(status_code=401, detail="Session required")
    
    user = get_current_user(session_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    return user

@app.post("/auth/login")
async def login(credentials: dict, session_id: str = None):
    """Login user (creates session)"""
    email = credentials.get("email")
    password = credentials.get("password")
    
    if not email or not password:
        raise HTTPException(status_code=400, detail="Email and password are required")
    
    # Generate session ID if not provided
    if not session_id:
        session_id = secrets.token_urlsafe(32)
    
    # Create user session
        user = User(
        id=secrets.token_urlsafe(16),
            username=email.split("@")[0],
            discogsUserId=None,
            email=email
        )
    
    session_data = {
        "user": user.model_dump(),
        "settings": UserSettings().model_dump(),
        "strategies": [s.model_dump() for s in DEFAULT_STRATEGIES],
        "logs": [],
        "suggestions": []
    }
    session_manager.set_session(session_id, session_data)
    
    return {
        "user": user,
        "session_id": session_id,
        "message": "Login successful"
    }

@app.post("/auth/setup")
async def setup_auth():
    """
    Initialize OAuth flow with Discogs
    Returns request token and authorization URL
    """
    consumer_key = os.getenv("DISCOGS_CONSUMER_KEY")
    consumer_secret = os.getenv("DISCOGS_CONSUMER_SECRET")
    
    if not consumer_key or not consumer_secret:
        raise HTTPException(status_code=500, detail="Discogs API credentials not configured")
    
    try:
        oauth = DiscogsOAuth(consumer_key, consumer_secret)
        request_token, request_token_secret = oauth.get_request_token("http://localhost:3000/auth/callback")
        auth_url = oauth.get_authorize_url(request_token)
        
        return {
            "requestToken": request_token,
            "requestTokenSecret": request_token_secret,
            "authUrl": auth_url
        }
    except Exception as e:
        logger.error(f"OAuth setup error: {e}")
        raise HTTPException(status_code=500, detail=f"OAuth setup failed: {str(e)}")

@app.post("/auth/verify")
async def verify_auth(verification: dict, session_id: str = None):
    """
    Verify OAuth authorization and get user access tokens
    """
    if not session_id:
        raise HTTPException(status_code=400, detail="Session ID required")
    
    consumer_key = os.getenv("DISCOGS_CONSUMER_KEY")
    consumer_secret = os.getenv("DISCOGS_CONSUMER_SECRET")
    
    if not consumer_key or not consumer_secret:
        raise HTTPException(status_code=500, detail="Discogs API credentials not configured")
    
    request_token = verification.get("requestToken")
    verifier_code = verification.get("verifierCode") or verification.get("oauthVerifier")
    request_token_secret = verification.get("requestTokenSecret")
    
    logger.info(f"OAuth verification attempt - token: {request_token}, secret: {request_token_secret}, verifier: {verifier_code}")
    
    if not request_token or not verifier_code or not request_token_secret:
        raise HTTPException(status_code=400, detail="Missing required OAuth parameters")
    
    try:
        oauth = DiscogsOAuth(consumer_key, consumer_secret)
        
        logger.info(f"Getting access token with verifier: {verifier_code}")
        access_token, access_token_secret = oauth.get_access_token(
            request_token, request_token_secret, verifier_code
        )
        logger.info(f"Successfully obtained access token: {access_token[:10]}...")
        logger.info(f"Access token secret: {access_token_secret[:10]}...")
        
        # Create authenticated client to get user info
        client = DiscogsClient(consumer_key, consumer_secret, 
                              access_token, access_token_secret)
        
        logger.info(f"Attempting to get user info with access token: {access_token[:10]}...")
        try:
            user_info = client.get_user_info()
            logger.info(f"Successfully retrieved user info: {user_info.get('username', 'unknown')}")
            logger.info(f"User info keys: {list(user_info.keys()) if user_info else 'None'}")
        except Exception as e:
            logger.error(f"Failed to get user info from Discogs: {e}")
            # Continue anyway - we'll create a basic user with the access tokens
            user_info = {"username": "discogs_user", "id": 1}
        
        # Update user session with Discogs data
        if not session_manager.has_session(session_id):
            raise HTTPException(status_code=404, detail="Session not found")
        
        session = session_manager.get_session(session_id)
        user_data = session["user"]
        
        # Update user with Discogs info
        user_data.update({
            "discogsUserId": user_info["id"],
            "username": user_info["username"],
            "email": user_info.get("email", user_data.get("email")),
            "firstName": user_info.get("first_name"),
            "lastName": user_info.get("last_name"),
            "accessToken": access_token,
            "accessTokenSecret": access_token_secret
        })
        
        # Save updated session data
        session_manager.update_session_data(session_id, "user", user_data)
        
        # Debug: Log stored tokens
        logger.info(f"Stored access token: {access_token[:10]}...")
        logger.info(f"Stored access token secret: {access_token_secret[:10]}...")
        logger.info(f"Updated user data for session: {session_id}")
    
        return {
            "user": User(**user_data),
        "message": "Account connected successfully"
    }
    except Exception as e:
        logger.error(f"OAuth verification error: {e}")
        raise HTTPException(status_code=400, detail=f"OAuth verification failed: {str(e)}")

@app.post("/auth/disconnect")
async def disconnect_auth(session_id: str = None):
    """Disconnect Discogs account"""
    if not session_id:
        raise HTTPException(status_code=400, detail="Session ID required")
    
    if not session_manager.has_session(session_id):
        raise HTTPException(status_code=404, detail="Session not found")
    
    # Remove Discogs data from user session
    session = session_manager.get_session(session_id)
    user_data = session["user"]
    
    user_data.update({
        "discogsUserId": None,
        "accessToken": None,
        "accessTokenSecret": None
    })
    
    # Save updated session data
    session_manager.update_session_data(session_id, "user", user_data)
    
    return {"message": "Account disconnected successfully"}

# Dashboard endpoints
@app.get("/dashboard/summary")
async def get_dashboard_summary(session_id: str = None):
    """Get dashboard summary with real data"""
    user = require_auth(session_id)
    require_discogs_auth(user)
    
    try:
        # Initialize Discogs client
        consumer_key = os.getenv("DISCOGS_CONSUMER_KEY")
        consumer_secret = os.getenv("DISCOGS_CONSUMER_SECRET")
        
        client = DiscogsClient(
            consumer_key=consumer_key,
            consumer_secret=consumer_secret,
            access_token=user.accessToken,
            access_token_secret=user.accessTokenSecret
        )
        
        # Get user inventory count
        inventory = client.get_user_inventory(user.username, per_page=1)
        total_listings = inventory.get("pagination", {}).get("items", 0)
        
        # Get latest log entry
        session = session_manager.get_session(session_id)
        latest_log = session["logs"][-1] if session["logs"] else None
        
        return {
            "totalListings": total_listings,
            "suggestedUpdates": len(session.get("suggestions", [])),
            "averageDelta": 0,  # Will be calculated from real suggestions
            "lastRunDate": latest_log["runDate"] if latest_log else None,
        "isRunning": False
    }
        
    except Exception as e:
        logger.error(f"Error getting dashboard summary: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get dashboard summary: {str(e)}")

@app.post("/simulate")
async def run_simulation(session_id: str = None):
    """Run real pricing analysis on user's inventory"""
    user = require_auth(session_id)
    require_discogs_auth(user)
    
    try:
        # Initialize Discogs client
        consumer_key = os.getenv("DISCOGS_CONSUMER_KEY")
        consumer_secret = os.getenv("DISCOGS_CONSUMER_SECRET")
        
        client = DiscogsClient(
            consumer_key=consumer_key,
            consumer_secret=consumer_secret,
            access_token=user.accessToken,
            access_token_secret=user.accessTokenSecret
        )
        
        # Get user info
        user_info = client.get_user_info()
        username = user_info.get("username")
        
        if not username:
            raise HTTPException(status_code=400, detail="Could not retrieve username from Discogs")
        
        return {
            "message": "Analysis completed successfully!",
            "username": username,
            "itemsScanned": 0,  # Will be populated by actual analysis
            "itemsUpdated": 0,
            "itemsSkipped": 0,
            "errors": 0
        }
        
    except Exception as e:
        logger.error(f"Error running simulation: {e}")
        raise HTTPException(status_code=500, detail=f"Analysis failed: {str(e)}")

# Inventory endpoints
@app.get("/inventory/suggestions")
async def get_suggestions(session_id: str = None):
    """
    Get pricing suggestions for user's inventory from Discogs
    Limited to 10 items for performance testing
    """
    user = require_auth(session_id)
    require_discogs_auth(user)
    
    consumer_key = os.getenv("DISCOGS_CONSUMER_KEY")
    consumer_secret = os.getenv("DISCOGS_CONSUMER_SECRET")
    
    if not consumer_key or not consumer_secret:
        raise HTTPException(status_code=500, detail="Discogs API credentials not configured")
    
    try:
        # Debug: Check access tokens
        logger.info(f"User access token: {user.accessToken[:10] if user.accessToken else 'None'}...")
        logger.info(f"User access token secret: {user.accessTokenSecret[:10] if user.accessTokenSecret else 'None'}...")
        
        # Initialize Discogs client
        client = DiscogsClient(
            consumer_key=consumer_key,
            consumer_secret=consumer_secret,
            access_token=user.accessToken,
            access_token_secret=user.accessTokenSecret
        )
        
        # Use the stored username from the session (avoid extra API call)
        username = user.username
        logger.info(f"Using stored username: {username}")
        
        if not username:
            raise HTTPException(status_code=400, detail="Could not get user username")
        
        # Get user's inventory - fetch items for analysis (limit to 10 for testing)
        inventory = client.get_user_inventory(username, per_page=10)
        listings = inventory.get("listings", [])
        
        logger.info(f"Processing {len(listings)} listings for suggestions...")
        suggestions = []
        
        # Process listings with real Discogs data
        for i, listing in enumerate(listings):
            try:
                logger.info(f"Processing listing {i+1}/{len(listings)}: {listing.get('id', 'unknown')}")
                
                # Extract listing data
                listing_id = listing["id"]
                current_price = float(listing["price"]["value"])
                condition = listing["condition"]
                sleeve_condition = listing.get("sleeve_condition", "Not Graded")
                release_id = listing.get("release", {}).get("id")
                
                if not release_id:
                    logger.warning(f"No release ID for listing {listing_id}, skipping")
                    continue
                
                # Get price suggestions from Discogs (with error handling)
                price_suggestions = None
                try:
                    price_suggestions = client.get_price_suggestions(release_id)
                    logger.debug(f"Got price suggestions for release {release_id}")
                except Exception as e:
                    logger.warning(f"Failed to get price suggestions for release {release_id}: {e}")
                
                # Get marketplace stats (with error handling)
                marketplace_stats = None
                try:
                    marketplace_stats = client.get_marketplace_stats(release_id)
                    logger.debug(f"Got marketplace stats for release {release_id}")
                except Exception as e:
                    logger.warning(f"Failed to get marketplace stats for release {release_id}: {e}")
                
                # Calculate suggested price based on strategy
                session = session_manager.get_session(session_id)
                active_strategy = next((s for s in session["strategies"] if s["isActive"]), DEFAULT_STRATEGIES[0])
                
                # Initialize stats variable
                stats = {}
                if marketplace_stats:
                    stats = marketplace_stats.get("stats", {})
                
                # Use Discogs price suggestions if available
                if price_suggestions and condition in price_suggestions:
                    base_price = price_suggestions[condition]["value"]
                    currency = price_suggestions[condition]["currency"]
                else:
                    # Fallback to marketplace stats
                    base_price = stats.get("median", current_price)
                    currency = "USD"
                
                # Apply strategy offset
                if active_strategy["offsetType"] == "percentage":
                    suggested_price = base_price * (1 + active_strategy["offset"] / 100)
                else:
                    suggested_price = base_price + active_strategy["offset"]
                
                # Determine confidence and basis
                confidence = "high" if price_suggestions else "medium"
                basis = f"Discogs {condition} +{active_strategy['offset']:.1f}%" if active_strategy["offsetType"] == "percentage" else f"Discogs {condition} +${active_strategy['offset']:.2f}"
                
                suggestion = PriceSuggestion(
                    listingId=listing_id,
                    releaseId=release_id,
                    currentPrice=current_price,
                    suggestedPrice=round(suggested_price, 2),
                    confidence=confidence,
                    basis=basis,
                    condition=condition,
                    sleeveCondition=sleeve_condition,
                    reason=basis,
                    reasoning=basis,
                    marketData={
                        "median": stats.get("median", 0),
                        "mean": stats.get("mean", 0),
                        "min": stats.get("min", 0),
                        "max": stats.get("max", 0),
                        "count": stats.get("count", 0),
                        "p25": stats.get("p25", 0),
                        "p75": stats.get("p75", 0),
                        "p90": stats.get("p90", 0),
                        "scarcity": "medium"
                    },
                    release=listing.get("release", {}),
                    artist=listing.get("release", {}).get("artist", "")
                )
                
                suggestions.append(suggestion)
                
            except Exception as e:
                logger.error(f"Error processing listing {listing_id}: {e}")
                continue
        
        # Store suggestions in session
        session_manager.update_session_data(session_id, "suggestions", [s.dict() for s in suggestions])
        
        return {
            "suggestions": [s.dict() for s in suggestions],
            "total": len(suggestions),
            "message": f"Found {len(suggestions)} pricing suggestions"
        }
        
    except Exception as e:
        logger.error(f"Error getting suggestions: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get suggestions: {str(e)}")

# Strategy endpoints
@app.get("/strategies")
async def get_strategies(session_id: str = None):
    """Get all strategies"""
    user = require_auth(session_id)
    session = session_manager.get_session(session_id)
    
    strategies = session["strategies"]
    active_strategy = next((s for s in strategies if s["isActive"]), None)
    
        return {
        "strategies": strategies,
        "activeStrategy": active_strategy
    }

@app.post("/strategies")
async def create_strategy(strategy_data: dict, session_id: str = None):
    """Create a new custom strategy"""
    user = require_auth(session_id)
    session = session_manager.get_session(session_id)
    
    # Generate unique ID
    strategy_id = f"custom_{len([s for s in session['strategies'] if s['id'].startswith('custom_')]) + 1}"
    
    # Validate strategy data
    required_fields = ["name", "anchorMetric", "offset", "offsetType"]
    for field in required_fields:
        if field not in strategy_data:
            raise HTTPException(status_code=400, detail=f"Missing required field: {field}")
    
    # Check for name conflicts
    existing_names = [s["name"] for s in session["strategies"]]
    if strategy_data["name"] in existing_names:
        raise HTTPException(status_code=400, detail="Strategy name already exists")
    
    # Create strategy
    strategy = Strategy(
        id=strategy_id,
        name=strategy_data["name"],
        description=strategy_data.get("description", ""),
        anchorMetric=strategy_data["anchorMetric"],
        offset=float(strategy_data["offset"]),
        offsetType=strategy_data["offsetType"],
        isActive=False
    )
    
    session["strategies"].append(strategy.dict())
    
        return {
        "strategy": strategy.dict(),
        "message": "Strategy created successfully"
    }

@app.put("/strategies/{strategy_id}")
async def update_strategy(strategy_id: str, strategy_data: dict, session_id: str = None):
    """Update an existing strategy"""
    user = require_auth(session_id)
    session = session_manager.get_session(session_id)
    
    # Find strategy
    strategy_index = None
    for i, s in enumerate(session["strategies"]):
        if s["id"] == strategy_id:
            strategy_index = i
            break
    
    if strategy_index is None:
        raise HTTPException(status_code=404, detail="Strategy not found")
    
    # Update strategy
    session["strategies"][strategy_index].update({
        "name": strategy_data.get("name", session["strategies"][strategy_index]["name"]),
        "description": strategy_data.get("description", session["strategies"][strategy_index]["description"]),
        "anchorMetric": strategy_data.get("anchorMetric", session["strategies"][strategy_index]["anchorMetric"]),
        "offset": float(strategy_data.get("offset", session["strategies"][strategy_index]["offset"])),
        "offsetType": strategy_data.get("offsetType", session["strategies"][strategy_index]["offsetType"])
    })
    
        return {
        "strategy": session["strategies"][strategy_index],
        "message": "Strategy updated successfully"
    }

@app.post("/strategies/apply-globally")
async def apply_strategy_globally(request: dict, session_id: str = None):
    """Apply a strategy globally"""
    user = require_auth(session_id)
    session = session_manager.get_session(session_id)
    
    strategy_id = request.get("strategy_id")
    if not strategy_id:
        raise HTTPException(status_code=400, detail="Strategy ID required")
    
    # Find strategy
    strategy = None
    for s in session["strategies"]:
        if s["id"] == strategy_id:
            strategy = s
            break
    
    if not strategy:
        raise HTTPException(status_code=404, detail="Strategy not found")
    
    # Deactivate all strategies
    for s in session["strategies"]:
        s["isActive"] = False
    
    # Activate selected strategy
    strategy["isActive"] = True
    
        return {
        "message": f"Strategy '{strategy['name']}' applied globally",
        "activeStrategy": strategy
    }

# Settings endpoints
@app.get("/settings")
async def get_settings(session_id: str = None):
    """Get user settings"""
    user = require_auth(session_id)
    session = session_manager.get_session(session_id)
    return session["settings"]

@app.put("/settings")
async def update_settings(settings: dict, session_id: str = None):
    """Update user settings"""
    user = require_auth(session_id)
    session = session_manager.get_session(session_id)
    
    session["settings"].update(settings)
    session_manager.update_session_data(session_id, "settings", session["settings"])
        return {
        "settings": session["settings"],
        "message": "Settings updated successfully"
    }

# Item strategies endpoints
@app.get("/inventory/item-strategies")
async def get_item_strategies(session_id: str = None):
    """Get item-specific strategies"""
    user = require_auth(session_id)
    session = session_manager.get_session(session_id)
    
    # For now, return empty list - this can be expanded later
        return {

@app.post("/inventory/item-strategies")
async def update_item_strategy(strategy_data: dict, session_id: str = None):
    """Update strategy for a specific item"""
    user = require_auth(session_id)
    session = session_manager.get_session(session_id)
    
    listing_id = strategy_data.get("listingId")
    strategy_id = strategy_data.get("strategyId")
    
    if not listing_id:
        raise HTTPException(status_code=400, detail="listingId is required")
    
    # For now, just return success - this can be expanded later
        return {

# Logs endpoints
@app.get("/logs")
async def get_logs(session_id: str = None):
    """Get run logs"""
    user = require_auth(session_id)
    session = session_manager.get_session(session_id)
    return session["logs"]

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)